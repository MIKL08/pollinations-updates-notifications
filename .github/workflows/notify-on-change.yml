name: Pollinations Models Monitor

on:
  schedule:
    - cron: '0 * * * *'
  workflow_dispatch:

permissions:
  contents: write

env:
  TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
  TELEGRAM_TO_TEXT: ${{ secrets.TELEGRAM_TO }}
  TELEGRAM_TO_IMAGE: ${{ secrets.TELEGRAM_TO }}
  TELEGRAM_TO_ERROR: ${{ secrets.TELEGRAM_TO_ERROR }}
  TELEGRAM_TO_BETA: ${{ secrets.TELEGRAM_TO }}

jobs:
  check-text-models:
    runs-on: ubuntu-latest
    steps:
      - name: Get current date
        id: date
        run: echo "date=$(date +'%Y-%m-%d')" >> $GITHUB_OUTPUT

      - name: Checkout saves branch for text models
        uses: actions/checkout@v4
        with:
          ref: saves
          sparse-checkout: |
            pollinations_text_models.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Fetch text models with retries
        id: fetch
        continue-on-error: true
        run: |
          set -euo pipefail
          for i in {1..3}; do
            if curl -sS --fail -A "github-actions-bot" "https://text.pollinations.ai/models" -o /tmp/text_models.json; then
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/3 failed"
            sleep 10
          done
          echo "::error::POLLINATIONS TEXT API IS DOWN - Failed after 3 attempts"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 0

      - name: Compare text models
        if: steps.fetch.outputs.status == 'success'
        id: compare
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, sys
          from pathlib import Path

          def normalize_model(m):
              m = dict(m)
              for key in ("input_modalities", "output_modalities", "voices", "tools"):
                  if key in m and isinstance(m[key], list):
                      m[key] = sorted(set(m[key]))
              return m

          tmp = Path("/tmp/text_models.json")
          try:
              data = json.loads(tmp.read_text(encoding="utf-8"))
          except Exception as e:
              print(f"::error::Failed to parse JSON: {e}")
              sys.exit(1)

          normalized = [normalize_model(m) for m in data]
          normalized.sort(key=lambda x: str(x.get("name","")))

          curr_txt = json.dumps(normalized, ensure_ascii=False, indent=2, sort_keys=True) + "\n"

          prev_path = Path("pollinations_text_models.json")
          lines = []

          if not prev_path.exists():
              prev_path.write_text(curr_txt, encoding="utf-8")
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/message.txt").write_text("First snapshot initialized. No notification sent.\n", encoding="utf-8")
              sys.exit(0)

          prev = json.loads(prev_path.read_text(encoding="utf-8"))

          def to_map(items):
              return {str(i.get("name","")): i for i in items if i.get("name")}

          prev_map = to_map(prev)
          curr_map = to_map(normalized)

          added = sorted(set(curr_map) - set(prev_map))
          removed = sorted(set(prev_map) - set(curr_map))
          common = sorted(set(prev_map) & set(curr_map))

          modified = {}

          def diff_dicts(o,n):
              d={}
              for k in sorted(set(o)|set(n)):
                  ov=o.get(k); nv=n.get(k)
                  if ov!=nv:
                      if isinstance(ov, list) and isinstance(nv, list):
                          if set(ov) != set(nv):
                              d[k] = {"old":ov, "new":nv}
                      else:
                          d[k] = {"old":ov, "new":nv}
              return d

          for name in common:
              d = diff_dicts(prev_map[name], curr_map[name])
              if d:
                  modified[name]=d

          has_changes = bool(added or removed or modified)

          if added:
              lines.append("\n<b>+ Added models:</b>")
              for n in added:
                  m=curr_map[n]
                  lines.append(f"  - <code>{n}</code> (Description: {m.get('description','?')})")

          if removed:
              lines.append("\n<b>- Deleted models:</b>")
              for n in removed:
                  m=prev_map[n]
                  lines.append(f"  - <code>{n}</code> (Description: {m.get('description','?')})")

          if modified:
              lines.append("\n<b>&gt; Updated models:</b>")
              for n in sorted(modified):
                  lines.append(f"  - <code>{n}</code> (Description: {m.get('description','?')}):")
                  for k,ch in modified[n].items():
                      lines.append(f"      ‚Ä¢ {k}: {ch['old']} ‚Üí {ch['new']}")

          if not has_changes:
              lines.append("No changes found.")

          Path("/tmp/message.txt").write_text("\n".join(lines) + "\n", encoding="utf-8")
          Path("/tmp/changed.flag").write_text("true" if has_changes else "false", encoding="utf-8")

          if has_changes:
              prev_path.write_text(curr_txt, encoding="utf-8")
          PY

          CHANGED=$(cat /tmp/changed.flag 2>/dev/null || echo false)
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

          {
            echo 'message<<EOF'
            cat /tmp/message.txt
            echo EOF
          } >> "$GITHUB_OUTPUT"

      - name: Commit updated text models snapshot
        if: steps.compare.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add pollinations_text_models.json
          git commit -m "Update text models snapshot [$(date +'%Y-%m-%d %H:%M')]"
          git push origin saves

      - name: Notify text model changes
        if: steps.compare.outputs.changed == 'true'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_TEXT }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            <b>üìú Pollinations AI (Legacy) Text Models Update:</b>
            ${{ steps.compare.outputs.message }}
          format: html

      - name: Alert text API failure
        if: steps.fetch.outputs.status == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_ERROR }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            ‚ÄºÔ∏è<i>Maybe</i> <b>Pollinations AI Text API is down</b>‚ÄºÔ∏è
            Failed 3 times to fetch models.
          format: html

  check-image-models:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout saves branch for image models
        uses: actions/checkout@v4
        with:
          ref: saves
          sparse-checkout: |
            pollinations_image_models.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Fetch image models with retries
        id: fetch
        continue-on-error: true
        run: |
          set -euo pipefail
          for i in {1..3}; do
            if curl -sS --fail -A "github-actions-bot" "https://image.pollinations.ai/models" -o /tmp/image_models.json; then
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/3 failed"
            sleep 10
          done
          echo "::error::IMAGE MODELS SOURCE IS DOWN - Failed after 3 attempts"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 0

      - name: Compare image models
        if: steps.fetch.outputs.status == 'success'
        id: compare
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, sys
          from pathlib import Path

          tmp = Path("/tmp/image_models.json")
          try:
              curr_list = json.loads(tmp.read_text(encoding="utf-8"))
              if not isinstance(curr_list, list):
                  raise ValueError("Expected a JSON array")
              curr_set = set(str(x) for x in curr_list if x)
          except Exception as e:
              print(f"::error::Failed to parse image models JSON: {e}")
              sys.exit(1)

          prev_path = Path("pollinations_image_models.json")
          lines = []

          if not prev_path.exists():
              prev_path.write_text(json.dumps(sorted(curr_set), indent=2) + "\n", encoding="utf-8")
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/message.txt").write_text("First image models snapshot initialized. No notification sent.\n", encoding="utf-8")
              sys.exit(0)

          try:
              prev_list = json.loads(prev_path.read_text(encoding="utf-8"))
              prev_set = set(str(x) for x in prev_list if x)
          except Exception as e:
              print(f"::error::Failed to parse previous image models: {e}")
              sys.exit(1)

          added = sorted(curr_set - prev_set)
          removed = sorted(prev_set - curr_set)
          has_changes = bool(added or removed)

          if added:
              lines.append("\n<b>+ Added models:</b>")
              for n in added:
                  lines.append(f"  - <code>{n}</code>")

          if removed:
              lines.append("\n<b>- Deleted models:</b>")
              for n in removed:
                  lines.append(f"  - <code>{n}</code>")

          if not has_changes:
              lines.append("No changes found.")

          Path("/tmp/message.txt").write_text("\n".join(lines) + "\n", encoding="utf-8")
          Path("/tmp/changed.flag").write_text("true" if has_changes else "false", encoding="utf-8")

          if has_changes:
              prev_path.write_text(json.dumps(sorted(curr_set), indent=2) + "\n", encoding="utf-8")
          PY

          CHANGED=$(cat /tmp/changed.flag 2>/dev/null || echo false)
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> "$GITHUB_OUTPUT"
          else
            echo "changed=false" >> "$GITHUB_OUTPUT"
          fi

          {
            echo 'message<<EOF'
            cat /tmp/message.txt
            echo EOF
          } >> "$GITHUB_OUTPUT"

      - name: Commit updated image models snapshot
        if: steps.compare.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add pollinations_image_models.json
          git commit -m "Update image models snapshot [$(date +'%Y-%m-%d %H:%M')]"
          git push origin saves

      - name: Notify image model changes
        if: steps.compare.outputs.changed == 'true'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_IMAGE }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            <b>üì† Pollinations AI (Legacy) Image Models Update:</b>
            ${{ steps.compare.outputs.message }}
          format: html

      - name: Alert image source failure
        if: steps.fetch.outputs.status == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_ERROR }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            ‚ÄºÔ∏è<i>Maybe</i> <b>Pollinations AI Image Models source is down</b>‚ÄºÔ∏è
            Failed 3 times to fetch image model list.
          format: html

  check-text-models-pollens:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout saves branch for pollens text models
        uses: actions/checkout@v4
        with:
          ref: saves
          sparse-checkout: |
            pollens_text_models.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Fetch text models with retries
        id: fetch
        continue-on-error: true
        run: |
          set -euo pipefail
          for i in {1..3}; do
            if curl -sS --fail -A "github-actions-bot" "https://gen.pollinations.ai/api/generate/text/models" -o /tmp/text_models.json; then
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/3 failed"
            sleep 10
          done
          echo "::error::POLLENS TEXT API IS DOWN - Failed after 3 attempts"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 0

      - name: Compare text models
        if: steps.fetch.outputs.status == 'success'
        id: compare
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, sys
          from pathlib import Path

          MAX_LEN = 3500
          tmp = Path("/tmp/text_models.json")
          try:
              data = json.loads(tmp.read_text(encoding="utf-8"))
          except Exception as e:
              print(f"::error::Failed to parse JSON: {e}")
              sys.exit(1)

          models = data.get("data", []) if isinstance(data, dict) else data
          normalized = [dict(m) for m in models]
          normalized.sort(key=lambda x: str(x.get("name","")))
          curr_txt = json.dumps(normalized, ensure_ascii=False, indent=2, sort_keys=True) + "\n"
          prev_path = Path("pollens_text_models.json")

          if not prev_path.exists():
              prev_path.write_text(curr_txt, encoding="utf-8")
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/parts_count.txt").write_text("0", encoding="utf-8")
              sys.exit(0)

          prev = json.loads(prev_path.read_text(encoding="utf-8"))
          prev_map = {str(i.get("name","")): i for i in prev if i.get("name")}
          curr_map = {str(i.get("name","")): i for i in normalized if i.get("name")}

          added = sorted(set(curr_map) - set(prev_map))
          removed = sorted(set(prev_map) - set(curr_map))
          common = sorted(set(prev_map) & set(curr_map))
          modified = {}

          def diff_dicts(o, n, prefix=""):
              d = {}
              for k in sorted(set(o.keys()) | set(n.keys())):
                  if k == "created": continue
                  full_key = f"{prefix}.{k}" if prefix else k
                  ov, nv = o.get(k), n.get(k)
                  if ov != nv:
                      if isinstance(ov, dict) and isinstance(nv, dict):
                          d.update(diff_dicts(ov, nv, full_key))
                      else:
                          d[full_key] = {"old": ov, "new": nv}
              return d

          for name in common:
              d = diff_dicts(prev_map[name], curr_map[name])
              if d: modified[name] = d

          if not (added or removed or modified):
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/parts_count.txt").write_text("0", encoding="utf-8")
              sys.exit(0)

          blocks = []
          for n in added:
              m = curr_map[n]
              blocks.append(("added", f"  - <code>{n}</code> (Description: {m.get('description','?')})"))
          for n in removed:
              m = prev_map[n]
              blocks.append(("removed", f"  - <code>{n}</code> (Description: {m.get('description','?')})"))
          for n in sorted(modified):
              m = curr_map[n]
              mlines = [f"  - <code>{n}</code> (Description: {m.get('description','?')}):"]
              for k, ch in sorted(modified[n].items()):
                  mlines.append(f"      ‚Ä¢ {k}: {ch['old']} ‚Üí {ch['new']}")
              blocks.append(("modified", "\n".join(mlines)))

          header = "<b>üí¨ Pollinations AI Text Models Update:</b>"
          sec_h = {"added": "\n<b>+ Added models:</b>", "removed": "\n<b>- Deleted models:</b>", "modified": "\n<b>&gt; Updated models:</b>"}

          parts = []
          cur_lines = []
          cur_sec = None
          cur_len = 0

          for sec, blk in blocks:
              to_add = []
              if sec != cur_sec:
                  to_add.append(sec_h[sec])
              to_add.append(blk)
              add_len = len("\n".join(to_add)) + 1

              if cur_len + add_len > MAX_LEN and cur_lines:
                  parts.append("\n".join(cur_lines))
                  cur_lines = [sec_h[sec], blk]
                  cur_len = len("\n".join(cur_lines)) + 1
                  cur_sec = sec
              else:
                  cur_lines.extend(to_add)
                  cur_len += add_len
                  cur_sec = sec

          if cur_lines:
              parts.append("\n".join(cur_lines))

          for i, p in enumerate(parts):
              Path(f"/tmp/message_part_{i}.txt").write_text(f"{header}\n{p}", encoding="utf-8")

          Path("/tmp/changed.flag").write_text("true", encoding="utf-8")
          Path("/tmp/parts_count.txt").write_text(str(len(parts)), encoding="utf-8")
          prev_path.write_text(curr_txt, encoding="utf-8")
          PY

          CHANGED=$(cat /tmp/changed.flag 2>/dev/null || echo false)
          echo "changed=$CHANGED" >> "$GITHUB_OUTPUT"
          echo "parts=$(cat /tmp/parts_count.txt 2>/dev/null || echo 0)" >> "$GITHUB_OUTPUT"

      - name: Commit updated pollens text models snapshot
        if: steps.compare.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add pollens_text_models.json
          git commit -m "Update pollens text models snapshot [$(date +'%Y-%m-%d %H:%M')]"
          git push origin saves

      - name: Notify text model changes
        if: steps.compare.outputs.changed == 'true'
        env:
          TG_TOKEN: ${{ env.TELEGRAM_TOKEN }}
          TG_CHAT: ${{ env.TELEGRAM_TO_BETA }}
        run: |
          PARTS=${{ steps.compare.outputs.parts }}
          for i in $(seq 0 $((PARTS - 1))); do
            MSG=$(cat /tmp/message_part_${i}.txt)
            curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg chat "$TG_CHAT" --arg text "$MSG" '{
                chat_id: $chat,
                text: $text,
                parse_mode: "HTML",
                disable_web_page_preview: true
              }')"
            sleep 1
          done

      - name: Alert text API failure
        if: steps.fetch.outputs.status == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_ERROR }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            ‚ÄºÔ∏è<i>Maybe</i> <b>Pollens AI Text API is down</b>‚ÄºÔ∏è
            Failed 3 times to fetch models.
          format: html

  check-image-models-pollens:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout saves branch for pollens image models
        uses: actions/checkout@v4
        with:
          ref: saves
          sparse-checkout: |
            pollens_image_models.json
          sparse-checkout-cone-mode: false
        continue-on-error: true

      - name: Fetch image models with retries
        id: fetch
        continue-on-error: true
        run: |
          set -euo pipefail
          for i in {1..3}; do
            if curl -sS --fail -A "github-actions-bot" "https://gen.pollinations.ai/api/generate/image/models" -o /tmp/image_models.json; then
              echo "status=success" >> $GITHUB_OUTPUT
              exit 0
            fi
            echo "Attempt $i/3 failed"
            sleep 10
          done
          echo "::error::POLLENS IMAGE MODELS SOURCE IS DOWN - Failed after 3 attempts"
          echo "status=failure" >> $GITHUB_OUTPUT
          exit 0

      - name: Compare image models
        if: steps.fetch.outputs.status == 'success'
        id: compare
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json, sys
          from pathlib import Path

          MAX_LEN = 3500
          tmp = Path("/tmp/image_models.json")
          try:
              data = json.loads(tmp.read_text(encoding="utf-8"))
          except Exception as e:
              print(f"::error::Failed to parse JSON: {e}")
              sys.exit(1)

          models = data.get("data", []) if isinstance(data, dict) else data
          normalized = [dict(m) for m in models]
          normalized.sort(key=lambda x: str(x.get("name","")))
          curr_txt = json.dumps(normalized, ensure_ascii=False, indent=2, sort_keys=True) + "\n"
          prev_path = Path("pollens_image_models.json")

          if not prev_path.exists():
              prev_path.write_text(curr_txt, encoding="utf-8")
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/parts_count.txt").write_text("0", encoding="utf-8")
              sys.exit(0)

          prev = json.loads(prev_path.read_text(encoding="utf-8"))
          prev_map = {str(i.get("name","")): i for i in prev if i.get("name")}
          curr_map = {str(i.get("name","")): i for i in normalized if i.get("name")}

          added = sorted(set(curr_map) - set(prev_map))
          removed = sorted(set(prev_map) - set(curr_map))
          common = sorted(set(prev_map) & set(curr_map))
          modified = {}

          def diff_dicts(o, n, prefix=""):
              d = {}
              for k in sorted(set(o.keys()) | set(n.keys())):
                  if k == "created": continue
                  full_key = f"{prefix}.{k}" if prefix else k
                  ov, nv = o.get(k), n.get(k)
                  if ov != nv:
                      if isinstance(ov, dict) and isinstance(nv, dict):
                          d.update(diff_dicts(ov, nv, full_key))
                      else:
                          d[full_key] = {"old": ov, "new": nv}
              return d

          for name in common:
              d = diff_dicts(prev_map[name], curr_map[name])
              if d: modified[name] = d

          if not (added or removed or modified):
              Path("/tmp/changed.flag").write_text("false", encoding="utf-8")
              Path("/tmp/parts_count.txt").write_text("0", encoding="utf-8")
              sys.exit(0)

          blocks = []
          for n in added:
              m = curr_map[n]
              blocks.append(("added", f"  - <code>{n}</code> (Description: {m.get('description','?')})"))
          for n in removed:
              m = prev_map[n]
              blocks.append(("removed", f"  - <code>{n}</code> (Description: {m.get('description','?')})"))
          for n in sorted(modified):
              m = curr_map[n]
              mlines = [f"  - <code>{n}</code> (Description: {m.get('description','?')}):"]
              for k, ch in sorted(modified[n].items()):
                  mlines.append(f"      ‚Ä¢ {k}: {ch['old']} ‚Üí {ch['new']}")
              blocks.append(("modified", "\n".join(mlines)))

          header = "<b>üñºÔ∏è Pollinations AI Image Models Update:</b>"
          sec_h = {"added": "\n<b>+ Added models:</b>", "removed": "\n<b>- Deleted models:</b>", "modified": "\n<b>&gt; Updated models:</b>"}

          parts = []
          cur_lines = []
          cur_sec = None
          cur_len = 0

          for sec, blk in blocks:
              to_add = []
              if sec != cur_sec:
                  to_add.append(sec_h[sec])
              to_add.append(blk)
              add_len = len("\n".join(to_add)) + 1

              if cur_len + add_len > MAX_LEN and cur_lines:
                  parts.append("\n".join(cur_lines))
                  cur_lines = [sec_h[sec], blk]
                  cur_len = len("\n".join(cur_lines)) + 1
                  cur_sec = sec
              else:
                  cur_lines.extend(to_add)
                  cur_len += add_len
                  cur_sec = sec

          if cur_lines:
              parts.append("\n".join(cur_lines))

          for i, p in enumerate(parts):
              Path(f"/tmp/message_part_{i}.txt").write_text(f"{header}\n{p}", encoding="utf-8")

          Path("/tmp/changed.flag").write_text("true", encoding="utf-8")
          Path("/tmp/parts_count.txt").write_text(str(len(parts)), encoding="utf-8")
          prev_path.write_text(curr_txt, encoding="utf-8")
          PY

          CHANGED=$(cat /tmp/changed.flag 2>/dev/null || echo false)
          echo "changed=$CHANGED" >> "$GITHUB_OUTPUT"
          echo "parts=$(cat /tmp/parts_count.txt 2>/dev/null || echo 0)" >> "$GITHUB_OUTPUT"

      - name: Commit updated pollens image models snapshot
        if: steps.compare.outputs.changed == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          git add pollens_image_models.json
          git commit -m "Update pollens image models snapshot [$(date +'%Y-%m-%d %H:%M')]"
          git push origin saves

      - name: Notify image model changes
        if: steps.compare.outputs.changed == 'true'
        env:
          TG_TOKEN: ${{ env.TELEGRAM_TOKEN }}
          TG_CHAT: ${{ env.TELEGRAM_TO_BETA }}
        run: |
          PARTS=${{ steps.compare.outputs.parts }}
          for i in $(seq 0 $((PARTS - 1))); do
            MSG=$(cat /tmp/message_part_${i}.txt)
            curl -s -X POST "https://api.telegram.org/bot${TG_TOKEN}/sendMessage" \
              -H "Content-Type: application/json" \
              -d "$(jq -n --arg chat "$TG_CHAT" --arg text "$MSG" '{
                chat_id: $chat,
                text: $text,
                parse_mode: "HTML",
                disable_web_page_preview: true
              }')"
            sleep 1
          done

      - name: Alert image source failure
        if: steps.fetch.outputs.status == 'failure'
        uses: appleboy/telegram-action@master
        with:
          to: ${{ env.TELEGRAM_TO_ERROR }}
          token: ${{ env.TELEGRAM_TOKEN }}
          message: |
            ‚ÄºÔ∏è<i>Maybe</i> <b>Pollens AI Image Models source is down</b>‚ÄºÔ∏è
            Failed 3 times to fetch image model list.
          format: html